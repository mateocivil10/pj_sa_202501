# -*- coding: utf-8 -*-
"""E_Montecarlo_Google.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MKldM1hHl-qdC9-FDLrA_FOd3YKO1bFJ
"""

!pip install yfinance
import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# 1. Especificar el ticker de la acción
ticker = 'GOOGL'  # Aquí puedes poner el ticker que desees, por ejemplo, AAPL para Apple

# 2. Descargar los precios históricos usando yfinance
data = yf.download(ticker, start="2021-01-01", end="2024-10-18")  # Especificamos el rango de fechas

# 3. Visualizar los primeros registros
print(data.head())

# 4. Opcional: Graficar los precios de cierre
import matplotlib.pyplot as plt

data['Close'].plot(title=f"Precio de Cierre de {ticker}")
plt.show()

#Vemos la estructura de los datos
data[data.index>'2024-01-01'].head()

# Instead of 'Adj Close', try using 'Close':
data['retornos'] = (data['Close'] / data['Close'].shift(1)).apply(lambda x: np.log(x))
data.head()

#Metodo 1
N=len(data)-1 #Menos 1 porque el primer elemento no tiene retorno
mu=data['retornos'].sum()/N
print('el parametro mu del modelo es: ', mu)

#Metodo 1
N = len(data['retornos']) -1 # Número total de retornos
sigma = np.sqrt(np.sum((data['retornos'] - mu)**2) / (N - 1))
print('el parametro sigma del modelo es: ', sigma)

#Metodo 2
sigma = data['retornos'].std()
sigma

#Procedemos a crear una funcion que modele el proceso estocastico
def MGB_acciones(mu,sigma,data,col_name,steps):

    #Los parametros de la funcion son:
    #mu -> Tasa de crecimiento esperada
    #sigma -> volatilidad del activo
    #data -> pandas df que contiene los retornos logaritmicos del activo en dias
    #col_name -> nombre de la columna de los retornos
    #steps -> numero de pasos hacia adelante en el proceso estocastico

    dt=1/252 # son solo 252 dias de traiding en el año.
    s0=data[col_name].iloc[-1] #Tomamos el ultimo elemento de los precios, ya que este sera el punto de partida
    et_vector=np.random.normal(loc=0, scale=1, size=steps) # Vector de numeros aletorios de media 0 y desviacion estandar 1
    exp_vector = np.exp((mu - (sigma**2) / 2) * dt + sigma * et_vector * np.sqrt(dt))

    st_1=[]

    for i in range(0,steps):

        if i==0:
            s=s0*exp_vector[0]
        else:
            s=st_1[i-1]*exp_vector[i]

        st_1.append(s)


    return st_1

#Probamos la funcion
#MGB_acciones(mu, sigma, data, 'Adj Close',252)

# Funcion que realiza graficos de lineas
def lineas_multiples(data, title='Gráfico de Múltiples Líneas', xlabel='Eje X', ylabel='Eje Y'):
    """
    Función para graficar múltiples líneas con colores aleatorios.

    Parámetros:
    - data: DataFrame de pandas con los datos a graficar.
    - title: Título del gráfico.
    - xlabel: Etiqueta del eje X.
    - ylabel: Etiqueta del eje Y.
    """
    plt.figure(figsize=(10, 6))  # Tamaño de la figura
    num_lines = data.shape[1]  # Número de líneas (columnas en el DataFrame)

    # Generar un color aleatorio para cada línea
    colors = np.random.rand(num_lines, 3)  # Colores aleatorios en RGB

    for i in range(num_lines):
        plt.plot(np.arange(1, data.shape[0] + 1), data.iloc[:, i], color=colors[i], label=f'Línea {i + 1}')  # Acceso corregido

    # Configurar título y etiquetas
    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)

    # Mostrar la cuadrícula
    plt.grid(True)

    # Mostrar leyenda
    #plt.legend()

    # Mostrar el gráfico
    plt.show()

!pip install yfinance
import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Now simulamos 500 veces cual podria ser el comportamiento del activo el proximo año
Montecarlo_results = pd.DataFrame()

sim=500

for i in range(0,sim):

    print(i)
    # Instead of 'Adj Close', try using 'Close':
    # Generate the simulated prices using MGB_acciones
    simulated_prices = MGB_acciones(mu, sigma, data, 'Close', 252)
    # Create a Series with the correct index for the simulated prices
    simulated_series = pd.Series(simulated_prices, index=pd.date_range(start=data.index[-1] + pd.DateOffset(days=1), periods=len(simulated_prices), freq='D'))

    # Instead of concatenating, assign the simulated series directly
    Montecarlo_results['sim_' + str(i)] = simulated_series  # Changed 'Adj Close' to 'Close' and removed concatenation

#Graficamos
lineas_multiples(Montecarlo_results, title='Gráfico de Múltiples Líneas', xlabel='Eje X', ylabel='Eje Y')

#Calculamos la probabilidad de perder 5% de la inversion inicial en el próximo año
s0=data['Close'].iloc[-1] # Changed 'Adj Close' to 'Close'
print('El precio de compra es: ', s0)

Montecarlo_results.tail()

precios_cierre = Montecarlo_results.iloc[-1,:] #Seleccionamos los precios finales a un año de inversion
precios_cierre

total = len(precios_cierre)
# Convert precios_cierre values to a NumPy array for comparison
# Use np.less for element-wise comparison
# Replicate s0*0.95 to match the length of precios_cierre.values
#Instead of using np.less directly on the Series, we use it on the values:
exito = np.sum(np.less(precios_cierre.values, np.repeat(s0*0.95, total))) #.values added here

p = exito / total

print(p * 100, '%')