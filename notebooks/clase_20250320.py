# -*- coding: utf-8 -*-
"""Clase_20250320.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10P-OT29KDKfCHpPGL029r2isS2rrm2KK
"""

import pandas as pd
import numpy as np

def vf_cte(pago, n, i):
    # pago -> Valor de la mensualidad
    # n -> Número de periodos
    # i -> interés en la periodicidad n

    pagos = np.ones(n) * pago
    print(pagos.sum())

    cap_factor = np.ones(n) * (1 + i) ** np.arange(n, 0, -1)
    resp_vector = pagos * cap_factor
    resp = resp_vector.sum()

    return resp

##Finanzas - Interes Compuesto

def vf_cte(pago, n, i):

  pagos = np.ones(n) * pago
  print(pagos.sum())
  cao_factor = np.ones(n) * (1 + i) ** np.arange(n,0,-1)
  resp_vector = pagos * cao_factor
  resp = resp_vector.sum()
  return resp

# Datos
edad_x = 30
sexo = 'H'
paga = 0.04  # el 12% restante lo aporta el empleador
salario = 7000000
# Acumulado = 960000000  # Línea comentada, no está activa
edad_jubilacion = 62
tasa_anual = 0.04

## Tenga en cuenta, el primer pago de la renta es justo a los 30 años, como si fuera hoy
pago_mensual = salario * 0.16
n = (edad_jubilacion - edad_x) * 12
i = tasa_anual / 12

vf = vf_cte(pago_mensual, n, i)  # Ejecuta la función creada antes
print(vf)

print(i)

print(n)

# Cargar tablas de mortalidad
ruta_m = '/content/TM_mujeres.xlsx'
ruta_h = '/content/TM_hombres.xlsx'
Tmort_m = pd.read_excel(ruta_m)
Tmort_h = pd.read_excel(ruta_h)

# Import the interp1d function from scipy.interpolate
from scipy.interpolate import interp1d


# Calcular la tabla mensual de los hombres y mujeres
T_hombre = TMensual(Tmort_h)
T_mujer = TMensual(Tmort_m)

# Mostrar las primeras 15 filas de la tabla de hombres
T_hombre.head(15)

def TMensual(Tmort):
    """
    Interpola los valores de l(x) en pasos de 1/12 (mensual) y calcula q(x) y p(x).

    Parameters:
    Tmort (DataFrame): DataFrame que contiene las columnas 'x' y 'l(x)'.

    Returns:
    DataFrame: DataFrame con valores interpolados de x, l(x), q(x) y p(x).
    """

    # Aseguramos que Tmort tiene las columnas adecuadas
    if 'x' not in Tmort.columns or 'l(x)' not in Tmort.columns:
        raise ValueError("El DataFrame debe contener las columnas 'x' y 'l(x)'")

    # Obtener los valores de x y l(x)
    x_values = Tmort['x'].values
    lx_values = Tmort['l(x)'].values

    # Crear una función de interpolación
    interp_function = interp1d(x_values, lx_values, kind='linear', fill_value='extrapolate')

    # Crear los nuevos valores de x con un paso de 1/12, hasta 110 (incluyendo 110)
    new_x = np.arange(x_values[0], 110 + 1/12, 1/12)  # Incrementos mensuales hasta 110

    # Calcular los valores de l(x) interpolados
    new_lx = interp_function(new_x)

    # Inicializar los arrays para q(x) y p(x)
    qx_values = np.zeros(len(new_x) - 1)  # Inicializar el array para q(x)
    px_values = np.zeros(len(new_x) - 1)  # Inicializar el array para p(x)

    # Calcular q(x) y p(x) para cada nuevo valor de x
    for i in range(len(new_x)-1):
        if new_lx[i] > 0:  # Evitar división por cero
            qx_values[i] = 1 - (new_lx[i + 1] / new_lx[i])  # q(x) = 1 - l(x + 1/12) / l(x)
        else:
            qx_values[i] = 0  # Si l(x) es 0, q(x) también debe ser 0

        px_values[i] = 1 - qx_values[i]  # p(x) = 1 - q(x)


    # Crear un nuevo DataFrame con los valores interpolados y calculados
    interpolated_df = pd.DataFrame({
        'x': new_x,  # Incluir hasta 110
        'l(x)': new_lx,  # Excluir el último por la misma razón
        'q(x)': np.append(qx_values, 1),  # Añadir el valor de q(110)
        'p(x)': np.append(px_values, 0)  # Añadir el valor de p(110)
    })

    return interpolated_df

def tmort_filtered(df,edad):
    qx_vec=df[df['x']>=edad]
    return qx_vec

T=tmort_filtered(T_hombre,edad_jubilacion)
T.head(15)

T['n'] = T['x'].apply(lambda x: x - edad_jubilacion) * 12

T['Vn'] = np.ones(len(T)) * (1 / (1 + i))
T['Vn'] = T.apply(lambda row: row['Vn'] ** row['n'], axis=1)

# Multiplicar la probabilidad de supervivencia por el valor presente
sum_vect = T['p(x)'] * T['Vn']

# Sumar todos los valores para obtener la suma total
suma = sum_vect.sum()
suma

c=ahorro_total/suma
c

#Mujeres
# Definición de variables
edad_jubilacion = 57
pago_mensual = salario * 0.16  # Asumiendo que tienes una variable salario
n = (edad_jubilacion - edad_x) * 12
i = tasa_anual / 12  # tasa de interés anual

# Calcular el valor futuro de una anualidad constante
vf = vf_cte(pago_mensual, n, i)
print(vf)

# Filtrar el DataFrame de mortalidad por género y edad de jubilación
# Changed 'mort_filtered' to 'tmort_filtered' and assumed 'mujer' is 'T_mujer'
T = tmort_filtered(T_mujer, edad_jubilacion).copy()  # Evita el SettingWithCopyWarning


# Crear la columna 'n'
T.loc[:, 'n'] = T['x'].apply(lambda x: (x - edad_jubilacion) * 12)

# Crear la columna 'Vn'
T.loc[:, 'Vn'] = np.ones(len(T)) * (1 / (1 + i)) ** T['n']

# Crear la columna 'P(x)'
# Assumed 'px' is 'p(x)'
T.loc[:, 'P(x)'] = T['p(x)'] * T['Vn']

# Calcular la suma
suma = T['P(x)'].sum()
print(suma)

Acumulado=96000000

#FOR PAGOS EN LA POSICION 0 + 96 Y EL RESTO SOLO PAGOS